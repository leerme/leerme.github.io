<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>leerme の Blog</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="leerme の Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="leerme の Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leerme の Blog">
  
    <link rel="alternative" href="/atom.xml" title="leerme の Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://ow7iaz7ej.bkt.clouddn.com/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

  
<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-85415703-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://ow7iaz7ej.bkt.clouddn.com/%E9%92%9F.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">leerme</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">leerme</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://ow7iaz7ej.bkt.clouddn.com/%E9%92%9F.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">leerme</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-static" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/06/static/" class="article-date">
  	<time datetime="2018-03-06T07:19:06.000Z" itemprop="datePublished">2018-03-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/static/">
        const extern static 详解
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不管是从事哪种语言的开发工作，const extern static 这三个关键字的用法和原理都是我们必须明白的。本文将对此做出非常详细的讲解。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const是这三个中最简单的一个关键字。主要用于声明常量。常量和变量的样子没什么两样，只是前者的值是不可修改的。</p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int const a;</div><div class="line">const int a;</div></pre></td></tr></table></figure></p>
<p>这两条语句都把a声明为一个整数，它的值不能被修改，在这里，这两条语句是等价的，只是表现形式不同。</p>
<p>那么问题来了，既然a的值是不能被修改的，那我应该如何让a在一开始就有一个值呢？答案分两种情况：</p>
<pre><code>1. 在声明时就赋值 int const a = 15;
2. 函数中被声明为const的形参在函数被调用时会得到形参的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int func(int const a) &#123;</div><div class="line">    return a + 10;</div><div class="line">&#125;</div><div class="line">int b = func(10);</div><div class="line">printf(&quot;%i&quot;,b);</div></pre></td></tr></table></figure>
</code></pre><p>打印结果为20，可以看出，a在调用func的时候被赋值为10；</p>
<p>当const修饰指针变量的时候，情况就变得更加有趣了，因为指针变量有两样东西都有可能成为常量，指针变量 和 它指向的实体。我们再看下边的这个例子：</p>
<p>首先我们先声明一个普通的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *p;</div></pre></td></tr></table></figure></p>
<p>我们在int和* 之间加上const，就变成了下边的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int const *p;</div></pre></td></tr></table></figure></p>
<p>那么现在p就变成了一个指向整型常量的指针了，你可以修改指针p的值，但不能修改p指向的值。我们举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b = 20;</div><div class="line">int const *p = &amp;a;</div><div class="line">int *p1 = &amp;b;</div><div class="line">p = p1;</div><div class="line">printf(&quot;%i&quot;,*p);</div></pre></td></tr></table></figure></p>
<p>上边的代码中，我们让p指向a，p1指向b，然后修改指针p，最后打印结果为20，这说明我们可以修改指针p的值。再看下边的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b = 20;</div><div class="line">int const *p = &amp;a;</div><div class="line">int *p1 = &amp;b;</div><div class="line">// 下边的代码会报错</div><div class="line">*p = 60;</div><div class="line">printf(&quot;%i&quot;,*p);</div></pre></td></tr></table></figure></p>
<p>好了，通过上边的代码相信大家应该能够明白const放在int和<code>*</code>之间的作用了，那么我们现在把const放在<code>*</code>和p之间会发生什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int  * const p;</div></pre></td></tr></table></figure></p>
<p>此时，指针p为一个指向整型的常量指针，也就是说不能修改指针的值，可以修改它指向的值。我们依然举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b = 20;</div><div class="line">int  * const p = &amp;a;</div><div class="line">*p = 50;</div><div class="line">printf(&quot;%i&quot;,a);</div></pre></td></tr></table></figure></p>
<p>由上边代码可以看出，我们通过p修改了a的值，同样，打印结果为50。我们尝试修改指针p：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int b = 20;</div><div class="line">int  * const p = &amp;a;</div><div class="line">*p = 50;</div><div class="line">int *p1 = &amp;b;</div><div class="line">// 下边代码会报错</div><div class="line">p = p1;</div><div class="line">printf(&quot;%i&quot;,a);</div></pre></td></tr></table></figure></p>
<p>注意：如果把代码写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int const * const p;</div></pre></td></tr></table></figure></p>
<p>无论是指针还是它指向的整型都是常量，不可修改。</p>
<p>使用说明： 当你声明变量时，如果变量的值不会被修改，你应该在声明中使用const关键字。这种做法不仅使你的意图在其他阅读你的程序的人面前得到更清晰的展现，而且当这个值被意外修改时，编译器能够发现这个问题。</p>
<p>作用域<br>可能很多同学会认为 作用域 很简单，其实不然，很多优秀的代码都有一个共同点，就是合理的利用了标识符的作用域。同样，这也与变量的存储属性有关系，后边我们会解释到的。</p>
<p>编译器能够确认四种不同的作用域，他们分别为：</p>
<p>代码块作用域（block scope）<br>文件作用域（file scope）<br>原型作用域（prototype scope）<br>函数作用域（function scope）<br>1.代码块作用域（block scope）<br>位于一对花括号之间的所有语句成为一个代码块。任何在代码块的开始位置声明的标识符都具有代码块作用域，表示他们可以被这个代码中的所有语句访问。</p>
<p>当代码块处于嵌套转态时，声明于内层代码块的标识符的作用域到达该代码块的尾部便告终止。然而，如果内层代码块有一个标识符的名字与外层代码块的一个标识符同名，内层的那个标识符就将隐藏外层的标识符—–外层的那个标识符无法在内层代码中通过名字访问。</p>
<p>这里说一些有意思的事，由于两个代码块的变量不可能同时存在，所以编译器可以把他们放到同一个内存地址中。</p>
<p>注意： 我们应该避免在嵌套的代码块中使用相同的变量名，这样会在程序的调试和维护期间引起混淆。</p>
<p>2.文件作用域（file scope）<br>任何在所有代码块之外声明的标识符都具有文件作用域（file scope),它表示这些标识符从他们的声明之处直到它所在的源文件结尾处都是可以访问的。</p>
<p>注意： 在头文件中通过#include或者#import导入的文件，就好像写到该头文件中一样，他们的作用域并不会局限于他们自身的文件中。</p>
<p>3.原型作用域（prototype scope）<br>原型作用域（prototype scope）可能不太好理解，我们看上图中的3和8，这两个函数被声明了。也就是说只在声明函数的时候，这个形参可有可无，名字和函数定义的形参可以相同，也可以不同，唯一能冲突的地方是，不能再同一函数声明中不止一次的使用同一名字。</p>
<p>4.函数作用域（function scope）<br>该作用域只适用于语句标签，语句标签用于goto语句，一个函数中的所有语句标签必须是唯一的。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">int i=1;</div><div class="line">tt:printf(&quot;%d\n&quot;,i++);</div><div class="line">if (i&lt;10)</div><div class="line">goto tt;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>链接属性<br>在讲解extern static之前，还必须了解链接属性这个概念，出现了链接这两个字，说明跟代码的编译有关系。</p>
<p>我们知道，当组成一个程序的各个源文件分别被编译后，所有的目标文件以及那些从一个或多个函数库引用的函数链接在一起，形成可执行文件。然而，会有这样一种情况，如果相同的标识符，比如说int a，出现在几个不同的源文件中时， 该怎么处理这种情况呢？</p>
<p>我们为每个标识符加一个属性，这个属性告诉编译器如何处理不同源文件中的标识符，那么这个属性就是链接属性。链接属性一共有三种：</p>
<p>external（外部） 属于external属性的标识符不论声明多少次，位于几个源文件，都表示同一实体。<br>internal（内部） 属于internal属性的标识符在同一个源文件内的所有声明都指向同一个实体，但不同源文件的多个声明分属不同的实体。<br>none（无） 没有链接属性的标识符（none）总是被当做单独的个体，也就是说该标识符的多个声明被当做独立不同的个体。<br>下边我用一个例子来演示一下上边说的内容：</p>
<p>首先我新建了一个工程，在main.m中写了下边代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#include &lt;float.h&gt;</div><div class="line"></div><div class="line">int a = 100;</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    </div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，定义了一个变量a，这个变量a默认属性为外部链接（external），也就是说我不能在别的文件中再次声明变量a了。然后我在ViewController.m中写了下边的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line">    </div><div class="line">    extern int a;</div><div class="line">    printf(&quot;a:%i -p:%p\n&quot;,a,&amp;a);</div><div class="line">    extern int a;</div><div class="line">    printf(&quot;a:%i -p:%p\n&quot;,a,&amp;a);</div><div class="line">    extern int a;</div><div class="line">    printf(&quot;a:%i -p:%p\n&quot;,a,&amp;a);</div><div class="line">    extern int a;</div><div class="line">    printf(&quot;a:%i -p:%p\n&quot;,a,&amp;a);</div><div class="line">    extern int a;</div><div class="line">    printf(&quot;a:%i -p:%p\n&quot;,a,&amp;a);</div><div class="line">&#125;</div><div class="line">打印结果：</div><div class="line"></div><div class="line">a:100 -p:0x10d9a0dc8</div><div class="line">a:100 -p:0x10d9a0dc8</div><div class="line">a:100 -p:0x10d9a0dc8</div><div class="line">a:100 -p:0x10d9a0dc8</div><div class="line">a:100 -p:0x10d9a0dc8</div></pre></td></tr></table></figure></p>
<p>可以看出，extern int a; 这一句的extern关键字把int a 的链接属性变成了外部链接，因此编译器就会去取main.m中的a的值。我虽然多次声明了extern int a;，但都指向了同一实体。</p>
<p>我们通过上面的代码，再次对链接属性进行解释。在缺省情况下，标识符b，c和f的链接属性为external。其余标识符的链接属性为none。比较特殊的是函数f。他其实是一个外部链接属性，就像我们调用系统函数一样，f只是一个函数名称。但我们在该源文件调用函数f时，可能会链接别的源文件中f的定义。甚至这个函数的定义出现在某个函数库中。</p>
<h3 id="extern-static"><a href="#extern-static" class="headerlink" title="extern / static"></a>extern / static</h3><p>其实，关键字extern和static用于在声明中修改标识符的链接属性。如果某个声明在正常情况下具有external链接属性，在它前面加上static关键字，可以使他的链接属性变为internal，也就是只能在源文件中被操作。</p>
<p>static是很有用的，当我们只想把一个变量或者函数限制在本源文件中，不行被别的文件或人员访问的时候，就是使用static的时候。</p>
<p>注意： static只对缺省链接属性为external的声明才具有改变链接属性的作用，在上图中的5中，把代码改成static int e;，这个时候static的作用就不是改变链接属性。而是为变量e分配一个静态内存，每次访问这个变量，都会在这个静态内存中取值。</p>
<p>从技术角度讲，这两个关键字只有在声明中才是必须的，当用于具有文件作用域的声明时，这个关键字是可选的。然而，如果你在一个地方定义变量，并在其他源文件使用这个变量的声明时添加extern关键字，可以使读者更容易理解你的用途。</p>
<p>当extern关键字用于源文件中一个标识符的第一次声明时，它指定该标识符具有external链接属性。但是，如果它由于该标识符的第2次或以后的声明时，它并不会更改由第一次声明所指定的链接属性。在下图中的声明4并不会改变i的链接属性。</p>
<h3 id="存储类型（storage-class）"><a href="#存储类型（storage-class）" class="headerlink" title="存储类型（storage class）"></a>存储类型（storage class）</h3><p>变量的存储类型这个概念对我们来说也很重要。变量的存储类型是指存储变量的内存类型。变量的存储类型决定变量何时创建，何时销毁以及它的值将保持多久。有三个地方可以存储变量：普通内存，运行时堆栈，硬件寄存器。</p>
<p>变量的缺省存储类型取决于它的声明位置。凡是在任何代码块之外声明的变量总是存储于静态内存中，也就是不属于堆栈的内存，这类变量称为静态变量。对于这类变量，你无法为它们指定其他存储类型。 静态变量在程序运行之前创建，在程序的整个执行期间始终存在，它始终保持原来的值，除非给他赋一个不同的值或程序结束。</p>
<p>在代码块内部声明的变量的缺省存储类型是自动的（automatic），也就是说它存储于堆栈中，称为自动变量。 有一关键字auto就是用于修饰这种存储类型的，但它极少用，因为代码块中的变量在缺省情况下就是自动变量。当程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时，这些自动变量便自行销毁。 也就是说函数的调用也是有时间的，为了让代码更快，可以适当的加入内联函数。</p>
<p>如果该代码块被数次执行，例如一个函数被反复调用，这些自动变量每次都将从新创建。在代码块再次执行时，这些自动变量在堆栈中所占用的内存位置有可能和原先的位置相同，也可能不同。即使他们所占据的位置相同，你也不能保证这块内存同时不会有其他的用途。因此我们可以说，自动变量在代码块执行完毕后就消失。</p>
<p>对于在代码块内部声明的变量，如果给他加上关键字static，可以使它的存储类型从自动变为静态。 具有静态存储类型的变量在整个程序执行过程中一直存在，而不仅仅在声明它的代码块的执行时存在。注意：修改变量的存储属性并不表示修改变量的作用域，它仍然只能在代码块内部按名字访问。</p>
<p>函数的形式参数不能声明为静态，因为实参总是在堆栈中传递给函数，用于支持递归。</p>
<p>关键字register可以用于自动变量的声明，提示他们应该存储于机器的硬件寄存器而不是内存中，这类变量称为寄存器变量。通常寄存器变量比存储于内存中的变量访问起来效率更高。但是编译器不一定要理睬register关键字，如果有太多的变量被声明为register，它只会选取前几个实际存储于寄存器中，其他的就按普通的自动变量处理。如果一个编译器自己具有一套寄存器优化方法，它也可能忽略register关键字，其依据是由编译器决定哪些变量存储于寄存器中比人脑的决定更为合理些。</p>
<p>在典型情况下，你希望把使用频率最高的那些变量声明为寄存器变量。在有些计算机中，如果把指针声明为寄存器变量，程序的效率将能得到提高，尤其是那些频繁执行间接访操作的指针。你可以把函数的形参声明为寄存器变量，编译器会在函数的起始位置生成指令，把这些值从堆栈复制到寄存器中。但是，完全有可能，这个优化措施所节省的时间和空间上的开销还抵不上复制和几个值所使用的开销。</p>
<p>我们举个例子，程序的计算是在cpu中执行的，那么要获取计算用的数据，可以在内存中获取，也可以在寄存器中获取，相对于内存来说，寄存器的读取效率更高一些。我们把数据放到寄存器中拱cpu读取，执行完毕后，在把寄存器原来的值恢复。</p>
<p>寄存器变量的创建和销毁时间和自动变量相同，但它需要一些额外的工作。在一个使用寄存器变量的函数返回之前，这些寄存器先前存储的值必须恢复，确保调用者的寄存器变量未被破坏，这也是为什么寄存器效率高德原因，不需要反复的创建和销毁实际存储的实体。许多机器使用运行时堆栈来完成这个任务。当程序开始执行时，它把需要使用的寄存器的内容都保存到堆栈中，当函数返回时，这些值再复制回寄存器中。</p>
<p>在许多机器的硬件实现中，并不为寄存器指定地址。同样，由于寄存器值得保存和恢复，某个特定的寄存器在不同的时刻所保存的值不一定相同。基于这个原理，机器并不向你提供寄存器变量的地址。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>现在我们把话题返回到变量声明中变量的初始化问题。自动变量和静态变量的初始化存在一个重要区别。</p>
<p>在静态变量的初始化中，我们可以把想要初始化的值放在当程序执行时变量将会使用的那个位置。当可执行文件载入到内存中时，这个已经保存了正确初始值的位置将赋值给那个变量。完成这个任务并不需要额外的时间，也不需要额外的指令，变量将会得到正确的值，因为已经知道变量的内存地址。如果不显式地指定初始值，静态变量将初始值为0.</p>
<p>自动变量的初始化需要更多的开销，因为当程序链接时还无法确定自动变量的存储位置。事实上，函数的局部变量在函数的每次调用中占据不同的位置。基于这个理由，自动变量没有缺省的初始值，而显式的初始化将在代码块的起始处插入一条隐式的赋值语句。</p>
<p>这种技巧造成4种后果：</p>
<p>自动变量的初始化较之赋值语句效率并无提高。 除了声明为const的变量之外，在声明变量的同时进行初始化和先声明后赋值只有风格之差，并无效率之别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int func(int x) &#123;</div><div class="line">    int a;</div><div class="line">    a = 100;</div><div class="line">    // 上边的代码是先声明后初始化，对于自动变量，跟 int a = 100; 没有效率上的区别</div><div class="line">    return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这条隐式的赋值语句，是自动变量在程序执行到他们所声明的函数时，每次都将重新初始化。这个与静态变量有大不同，后者只是在程序开始执行前初始化一次。<br>由于初始化在运行时进行，你可以用任何表达式作为初始化值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int func(int x) &#123;</div><div class="line">    // 由于自动变量实在运行时才赋值的，所以当运行到下边的代码时，已经知道x的值，然后给a赋值</div><div class="line">    int a = x + 10;</div><div class="line">    return a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除非你对自动变量进行显示的初始化，否则当自动变量创建时，它们的值总是垃圾。</p>
<h3 id="static总结"><a href="#static总结" class="headerlink" title="static总结"></a>static总结</h3><p>当用于不同的上下文环境时，static关键字具有不同的意思。</p>
<p>当它用于函数定义时，或用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性，从external改为internal，但标识符的存储类型和作用域不受影响。用这种方式声明的函数或变量只能在声明他们的源文件中访问。<br>当它用于代码块内部的变量声明时，static关键字用于修改变量的存储类型。从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。用这种方式声明的变量在程序执行之前创建，并在程序的整个执行期间一直存在。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-你理解多线程吗？" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/02/你理解多线程吗？/" class="article-date">
  	<time datetime="2017-11-02T07:20:12.000Z" itemprop="datePublished">2017-11-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/02/你理解多线程吗？/">
        你理解多线程吗？
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工作忙完一段时间，整理资料，总结知识，发现对多线程这块有点遗忘，写篇博客谈谈多线程，温故而知新。<br>大家面试，想必都会被问到，你理解多线程吗？还可能追问道<br>1、有哪几种多线程，基于什么语言的？<br>2、生命周期是如何管理的？<br>3、你更倾向于那种？现在常用的两种，谈谈你的看法？</p>
<h3 id="第一种：pthread"><a href="#第一种：pthread" class="headerlink" title="第一种：pthread"></a>第一种：pthread</h3><p><strong>特点：</strong><br>1、一套通用的多线程API<br>2、适用于Unix、Linux、Windows等系统<br>3、跨平台、可移植<br>4、使用难度大<br>5、使用语言：C语言<br>6、开发使用频率：几乎不用，<br>7、线程生命周期：由程序员进行管理 </p>
<h3 id="第二种：NSThread"><a href="#第二种：NSThread" class="headerlink" title="第二种：NSThread"></a>第二种：NSThread</h3><p><strong>特点：</strong><br>1、使用更加面向对象<br>2、简单易用，可直接操作线程对象<br>3、使用语言：OC语言<br>4、开发使用频率：偶尔使用<br>5、线程生命周期：由程序员进行管理 </p>
<h3 id="第三种：GCD"><a href="#第三种：GCD" class="headerlink" title="第三种：GCD"></a>第三种：GCD</h3><p><strong>特点：</strong><br>1、旨在替换NSThread等线程技术<br>2、充分利用设备的多核（自动）<br>3、使用语言：C语言<br>4、开发使用频率：经常使用<br>5、线程生命周期：自动管理</p>
<h3 id="第四种：NSOperation"><a href="#第四种：NSOperation" class="headerlink" title="第四种：NSOperation"></a>第四种：NSOperation</h3><p><strong>特点：</strong><br>1、基于GCD（底层是GCD)<br>2、比GCD多了一些更简单的实用的功能<br>3、使用更加面向对象<br>4、使用语言：OC语言<br>5、开发使用频率：经常使用<br>6、线程生命周期：自动管理</p>
<h3 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h3><p>同一时间，CPU只能处理1条线程，只有一条线程在工作，多线程并发执行，其实就是CPU快速的在多条线程之间调度，如果CPU调度线程的时间足够快，就造成了多线程并发的假象了；<br><strong>思考</strong> 如果线程非常多，会发生什么情况？<br>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频率被大大降低。</p>
<h3 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h3><p>能适当的提高程序执行的频率<br>能适当提高资源利用率（CPU）</p>
<h3 id="多线程缺点"><a href="#多线程缺点" class="headerlink" title="多线程缺点"></a>多线程缺点</h3><p>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M,子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能，线程越多，CPU在调度线程上的开销就越大，程序设计更加复杂：比如线程之间的通信，多线程的数据共享。</p>
<h3 id="你更倾向于哪一种？"><a href="#你更倾向于哪一种？" class="headerlink" title="你更倾向于哪一种？"></a>你更倾向于哪一种？</h3><p>就本人而已我是倾向于GCD的  所以下面主要结合实例谈谈GCD<br>GCD技术是一个轻量级，底层实现隐藏的申请技术，我们能够通过GCD和Block轻松实现多线程编程，有时候，GCD相比其他系统提供的多线程方法更加有效，当然，有时候GCD不是最佳选择，另一个多线程技术NSOperationQueue让我们能够将后台线程以队列方式依序执行，并提供更多操作入口，这和GCD的实现有些类似。</p>
<h3 id="GCD执行原理"><a href="#GCD执行原理" class="headerlink" title="GCD执行原理"></a>GCD执行原理</h3><p>GCD有一个底层线程池，这个池中的线程可以重用，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少线程是由底层线程池决定的（建议3-5），池是系统自动来维护，我们只需要关系的是向队列中添加任务，队列调度即可。<br>1.如果队列中存放都是同步任务，则任务出队后，底层线程池会提供一条线程供和这个任务执行，任务执行完毕后这条线程在回到线程池，这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程、<br>2.如果队列中存放的是异步任务，当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需要等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后在回到底层的线程池中。</p>
<h3 id="通过案例了解GCD的执行原理"><a href="#通过案例了解GCD的执行原理" class="headerlink" title="通过案例了解GCD的执行原理"></a>通过案例了解GCD的执行原理</h3><p><strong>案例一</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   NSLog(@&quot;1&quot;);</div><div class="line">   dispatch_sync(dispatch_get_main_queue(),^&#123;</div><div class="line"></div><div class="line">       NSLog(@&quot;2&quot;);</div><div class="line">   &#125;);</div><div class="line">   NSLog(@&quot;3&quot;);</div><div class="line">输出结果：1</div></pre></td></tr></table></figure></p>
<p><strong>分析</strong> 首先执行任务1，接下来程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后在执行任务3。但是这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务，那么，现在任务2就被加到最后了，任务3排在了任务2前面，问题来了：任务3要等任务2执行完才能执行，任务2又排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等等的局面，就卡在这里，发生死锁。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/8%E5%9B%BE1.png" alt=""><br><strong>案例二</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   NSLog(@&quot;1&quot;);</div><div class="line">   dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0),^&#123;</div><div class="line">       NSLog(@&quot;2&quot;);</div><div class="line">   &#125;);</div><div class="line">   NSLog(@&quot;3&quot;);</div><div class="line"></div><div class="line">输出结果：1 2 3</div></pre></td></tr></table></figure></p>
<p><strong>分析</strong> 首先执行任1，接下来会遇到一个同步线程，程序会进入等待，等待任务2执行完成以后，才能继续任务3，从dispatch_get_global_queue可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完成任务2后，返回到主队列，继续执行任务3<br><img src="http://ow7iaz7ej.bkt.clouddn.com/8%E5%9B%BE2.png" alt=""><br><strong>案例三</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">NSLog(@&quot;1&quot;);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    NSLog(@&quot;2&quot;);</div><div class="line">    dispatch_sync(queue, ^&#123;</div><div class="line">        NSLog(@&quot;3&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;4&quot;);</div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;5&quot;);</div><div class="line">输出结果：1 5 2</div></pre></td></tr></table></figure></p>
<p><strong>案例四</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   NSLog(@&quot;1&quot;);</div><div class="line">   dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">       NSLog(@&quot;2&quot;);</div><div class="line">       dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">           NSLog(@&quot;3&quot;);</div><div class="line">       &#125;);</div><div class="line">       NSLog(@&quot;4&quot;);</div><div class="line">   &#125;);</div><div class="line">   NSLog(@&quot;5&quot;);</div><div class="line">输出结果：1 5 2 3 4</div></pre></td></tr></table></figure></p>
<p><strong>分析</strong> 首先将【任务1、异步线程、任务5】加入到MainQueue中，异步线程中的任务是，【任务2，同步线程、任务4】。所以，先执行任务1，然后将异步线程中的任务加入到GlobalQueue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。然后在看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程，将同步线程中的任务加入到MainQueue中，这时加入的任务3在任务5的后面，当任务3执行完以后，没有了阻塞，程序继续执行任务4<br><img src="http://ow7iaz7ej.bkt.clouddn.com/8%E5%9B%BE4.png" alt=""><br><strong>案例五</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">       NSLog(@&quot;1&quot;);</div><div class="line">       dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">           NSLog(@&quot;2&quot;);</div><div class="line">       &#125;);</div><div class="line">       NSLog(@&quot;3&quot;);</div><div class="line">   &#125;);</div><div class="line">   NSLog(@&quot;4&quot;);</div><div class="line">   while (1) &#123;</div><div class="line">       </div><div class="line">   &#125;</div><div class="line">   NSLog(@&quot;5&quot;);</div><div class="line">输出结果：4 1</div></pre></td></tr></table></figure></p>
<p><strong>分析</strong> 和上面几个案例的分析类似，先来看看都有哪些任务加入了Main_Queue：【异步线程、任务4、死循环、任务5】。加入到Global_Queue异步线程中的任务有：【任务1、同步任务、任务3】。第一个就是异步线程，任务4不用等待，所以结果任务1，和任务4顺序不一定，任务4完成后，程序进入死循环，Main_Queue阻塞。但是加入到Global_Queue的异步线程不受影响，继续执行任务1后面的同步线程。同步线程中，将任务2加入到了主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/8%E5%9B%BE5.png" alt=""></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-App更换图标" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/27/App更换图标/" class="article-date">
  	<time datetime="2017-10-27T05:52:27.000Z" itemprop="datePublished">2017-10-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/27/App更换图标/">
        iOS App更换图标
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前段时间查看Apple官方文档，发现了一个新功能就是更换App图标，发现这个功能后，一顿暗喜，装逼的时候又到了! 可以给用户更好的体验、</p>
<p>例如可以在不同的节日更换不同的图标啦<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E8%8A%82%E6%97%A5%E5%9B%BE%E6%A0%87.jpg" alt="屏幕截图"></p>
<p>美中不足的是该功能（API）当前只支持<strong>iOS10.3</strong>以上的系统，所以只能当做一项附加功能来进行使用。下面将详细讲解下如何使用代码来实现此功能。</p>
<p>该功能应用的场景<br>1、白天/夜间模式切换，在切换App主色调同时切换App图标。<br>2、各类皮肤主题（淘宝就可换肤），附带App图标一块更换。<br>3、利用App图标表达某种特定功能，如节日，天气。</p>
<a href="https://developer.apple.com/documentation/uikit/uiapplication/2806818-setalternateiconname?preferredLanguage=occ" target="_blank" rel="external">API与文档</a>
<h3 id="API方法"><a href="#API方法" class="headerlink" title="API方法"></a>API方法</h3><p><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A31.png" alt=""></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>1、supportsAlternateIcons<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A32.png" alt=""><br>只有系统允许改变你的app图标时该值才为YES。你需要在Info.plist文件中的CFBundleIcons这个键内声明可更换的app图标。</p>
<p>2、alternateIconName<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A33.png" alt=""><br>当系统展示的是你更换后的app图标时，该值即为图标名字（Info.plist中定义的图标名字）。如果展示的是主图标时，这个值为nil。</p>
<p>3、setAlternateIconName:completionHandler:<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A34.png" alt=""><br>alertnateIconName参数：该参数为需要更换的app图标名字，是在你的Info.plist中的CFBundleAlertnateIcons键里定义的。如果你想显示的是用CFBundlePrimaryIcon键所定义的主图标的话，就传入nil。CFBundleAlertnateIcons与CFBundlePrimaryIcon键都是在CFBundleIcons里面定义的。</p>
<p>completionHandler参数：该参数用来处理（更换）结果。当系统尝试更改app的图标后，会将结果数据通过该参数传入并执行（该执行过程是在UIKit所提供的队列执行，并非主队列）。该执行过程会携带一个参数：error。如果更换app图标成功，那么这个参数就是nil。如果更换过程中发生了错误，那么该对象会指明错误信息，并且app的图标保持不变。</p>
<p><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A35.png" alt=""><br>使用该方法改变app图标为主图标或者可更换的图标。只有在supportsAlternateIcons的返回值为YES时才能更换</p>
<p>你必须在Info.plist文件的CFBundleIcons键里面声明可以更换的app图标（主图标和可更换图标）。如果需要获取关于可更换图标的配置信息，请查阅 <a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247" target="_blank" rel="external">Information Property List Key</a> 里面有关CFBundleIcons的描述。</p>
<h3 id="可变更App图标的配置方法"><a href="#可变更App图标的配置方法" class="headerlink" title="可变更App图标的配置方法"></a>可变更App图标的配置方法</h3><p><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E6%96%87%E6%A1%A36.png" alt=""><br>Info.plist是个字典，假设为NSDictionary *infoPlist。</p>
<p>1.CFBundleIcons是Info.plist字典里的一个键@”CFBundleIcons”。<br>2.CFBundleIcons对应的value是个字典。<br>3.CFBundleIcons里面能够包含的键有：CFBundlePrimaryIcon、CFBundleAlternateIcons、UINewsstandIcon。</p>
<p>代码展示下这个绕口的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NSDictionary *infoPlist;</div><div class="line">infoPlist = @&#123;</div><div class="line">               @&quot;CFBundleIcons&quot; : @&#123;</div><div class="line">                                     @&quot;CFBundlePrimaryIcon&quot; : xxx,</div><div class="line">                                     @&quot;CFBundleAlternateIcons&quot; : xxx,</div><div class="line">                                     @&quot;UINewsstandIcon&quot; : xxx</div><div class="line">                                   &#125;</div><div class="line">             &#125;;</div></pre></td></tr></table></figure></p>
<p>1.CFBundleAlternateIcons所对应的value是个字典（iOS中），假设为NSDictionary * alertnateIconsDic。<br>2.alertnateIconsDic的键，都是备用图标的名字，假设为@”newAppIcon”和@”newAppIcon2”。<br>3.@”newAppIcon”的value是个包含CFBundleIconFiles和UIPrerenderedIcon这两个键的字典。<br>4.CFBundleIconFiles的value是字符串或者数组（数组内容也为字符串）。字符串的内容为各尺寸备用图标的名字。<br>5.UIPrerenderedIcon的value是BOOL值。这个键值所代表的作用在iOS7之后（含iOS7）已失效，在iOS6中可渲染app图标为带高亮效果。所以这个值目前我们可以不用关心。<br>代码展示下这个绕口的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@&quot;CFBundleAlternateIcons&quot; : @&#123;</div><div class="line">                               @&quot;newAppIcon&quot; : @&#123;</div><div class="line">                                                 @&quot;CFBundleIconFiles&quot; : @[</div><div class="line">                                                      					  @&quot;newAppIcon&quot;</div><div class="line">                                                    					 ],</div><div class="line">                                                 @&quot;UIPrerenderedIcon&quot; : NO</div><div class="line">                                				&#125;,</div><div class="line">                               @&quot;newAppIcon2&quot; : @&#123;</div><div class="line">                                                 @&quot;CFBundleIconFiles&quot; : @[</div><div class="line">                                                      					  @&quot;newAppIcon2&quot;</div><div class="line">                                                                         ],</div><div class="line">                                                 @&quot;UIPrerenderedIcon&quot; : NO</div><div class="line">                                				 &#125;</div><div class="line">							 &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="实际配置文件-Info-plist"><a href="#实际配置文件-Info-plist" class="headerlink" title="实际配置文件(Info.plist)"></a>实际配置文件(Info.plist)</h3><p>对照着上述的配置文档，我们实际配置完的Info.plist是这样子的：<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E9%A1%B9%E7%9B%AE1.png" alt=""><br>拖入对应的App图标：<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E9%A1%B9%E7%9B%AE2.png" alt=""><br>在Build Phases -&gt; Copy Bundle Resources加入对应的图片资源<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E9%A1%B9%E7%9B%AE3.png" alt=""></p>
<p>然后调用此代码，传入对应的图标名称就可以看到App图标发生了改变啦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)setAppIconWithName:(NSString *)iconName &#123;</div><div class="line">    if (![[UIApplication sharedApplication] supportsAlternateIcons]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if ([iconName isEqualToString:@&quot;&quot;]) &#123;</div><div class="line">        iconName = nil;</div><div class="line">    &#125;</div><div class="line">    [[UIApplication sharedApplication] setAlternateIconName:iconName completionHandler:^(NSError * _Nullable error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            NSLog(@&quot;更换app图标发生错误了 ： %@&quot;,error);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>难受 苹果限制真多，上传提交审核的时候出现了。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/7%E9%A1%B9%E7%9B%AE4.png" alt=""><br>老老实实在info.plist里面加上这个key</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-iOS11上的一些问题" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/20/iOS11上的一些问题/" class="article-date">
  	<time datetime="2017-10-20T07:42:37.000Z" itemprop="datePublished">2017-10-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/20/iOS11上的一些问题/">
        项目在iOS11上遇到的小问题
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS11正式版出了这么久了，在忙完新版本开发，写下在iOS11上的一些小问题。</p>
<h3 id="一、App图标不显示"><a href="#一、App图标不显示" class="headerlink" title="一、App图标不显示"></a>一、App图标不显示</h3><p><strong>现象</strong>：升级到iOS11系统下自己的项目桌面app图标不见了<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE3.jpg" alt="图标不见"><br>出现这种情况我还以为自己手动删除了项目 <strong>Images.xcassets</strong>中的<strong>AppIcon</strong>导致没有图标。查看项目和发现这些AppIcon还在，突然发现在Xcode 9中AppIcon有了改变。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE2.png" alt="AppIcon"><br>发现Xcode 8及之前的版本是可以直接在iTunes Connect上添加App icon。而Xcode 9则是把App icon放置在项目的asset catalog。所以需要把空缺的图标补上，其中一张是1024pt 1x的尺寸。如果没有正确添加iOS App图标，上传到App Store后可能会受到拒绝邮件。<br>心想既然图标变了那么<strong>LaunchImage</strong>呢，果不其然LaunchImage也有小变化为了适配苹果即将售出的iPHone X，这里我们需要在这里添加一张新的尺寸图1125px*2436px。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE1.png" alt="LaunchImage"><br>那么究竟是什么导致，在iOS 11上面图标消失的呢。查证后发现。</p>
<p><strong>原因</strong>： 使用了CocoaPods的Xcode工程,在iOS11版的手机上AppIcon不显示,原因是CocoaPods的资源编译脚本在iOS11下出了点问题。</p>
<p><strong>解决办法</strong>：<br>1.在Podfile添加脚本修改：<br>1). 在Podfile 添加如下代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">post_install do |installer|</div><div class="line">    copy_pods_resources_path = &quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&quot;</div><div class="line">    string_to_replace = &apos;--compile &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;&quot;&apos;</div><div class="line">    assets_compile_with_app_icon_arguments = &apos;--compile &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;&quot; --app-icon &quot;$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;&quot; --output-partial-info-plist &quot;$&#123;BUILD_DIR&#125;/assetcatalog_generated_info.plist&quot;&apos;</div><div class="line">    text = File.read(copy_pods_resources_path)</div><div class="line">    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</div><div class="line">    File.open(copy_pods_resources_path, &quot;w&quot;) &#123;|file| file.puts new_contents &#125;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>需要注意的是,将[工程名] 换成自己工程的名称</p>
<p>2).然后运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$pod install</div></pre></td></tr></table></figure>
<p>2.手动修改<br>打开工程目录下:[工程名]/Pods/Target Support Files/Pods/Pods-resources.sh这个文件,替换最后一段代码:</p>
<p>修改前:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf &quot;%s\0&quot; &quot;$&#123;XCASSET_FILES[@]&#125;&quot; | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform &quot;$&#123;PLATFORM_NAME&#125;&quot; --minimum-deployment-target &quot;$&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125;&quot; $&#123;TARGET_DEVICE_ARGS&#125; --compress-pngs --compile &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>修改后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">printf &quot;%s\0&quot; &quot;$&#123;XCASSET_FILES[@]&#125;&quot; | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform &quot;$&#123;PLATFORM_NAME&#125;&quot; --minimum-deployment-target &quot;$&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125;&quot; $&#123;TARGET_DEVICE_ARGS&#125; --compress-pngs --compile &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;&quot; --app-icon &quot;$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;&quot; --output-partial-info-plist &quot;$&#123;BUILD_DIR&#125;/assetcatalog_generated_info.plist&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>然后重新运行工程即可,配置完成后如果启动后发现还没有图标，现在系统低于iOS 11下的手机运行一次，再在iOS 11上启动就回发现有了。</p>
<p>参考：<a href="https://github.com/CocoaPods/CocoaPods/issues/7003" target="_blank" rel="external">https://github.com/CocoaPods/CocoaPods/issues/7003</a></p>
<h3 id="二、用到相机功能时闪退"><a href="#二、用到相机功能时闪退" class="headerlink" title="二、用到相机功能时闪退"></a>二、用到相机功能时闪退</h3><p><strong>现象</strong>：在用户在手机系统iOS 11里面使用App进行身份证、银行卡ORC识别的时候打开相机发生Crash现象；在iOS 11以下正常。<br><strong>原因</strong>：iOS11下，苹果对相册的权限key做了调整<br>详见：<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW17" title="[external] [CocoaKeys]" target="_blank" rel="external">CocoaKeys</a><br><strong>解决办法</strong>：在Info.plist里添加以下权限<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE4.png" alt="添加权限"></p>
<h3 id="三、H5和Native交互的时候控制更严格"><a href="#三、H5和Native交互的时候控制更严格" class="headerlink" title="三、H5和Native交互的时候控制更严格"></a>三、H5和Native交互的时候控制更严格</h3><p><strong>现象</strong>：在iOS 11上点击UIWebView加载的H5页面，来与原生App进行交互出现Crash，报错webTread。</p>
<p><strong>原因</strong>：iOS11下，UIWebView与原生交互的时候出现了线程安全问题；控制更加严格。</p>
<p><strong>解决办法</strong>：把调用原生方法的代码放到主线程中运行。<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE5.png" alt="web和Native交互"></p>
<h3 id="四、在Xcode-9中的无线调试"><a href="#四、在Xcode-9中的无线调试" class="headerlink" title="四、在Xcode 9中的无线调试"></a>四、在Xcode 9中的无线调试</h3><p>Xcode 9 里面把很多简单的快捷键给改复杂了，一些插件不支持了。最有利于开发者的地方就是Xcode 9中的无线调试了。<br>苹果诟病最多的产品：数据线<br>心疼的抱住我自己，穿着缝缝补补的衣服，用着自己拼拼接接的数据线<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE7.jpeg" alt="我的数据线"></p>
<p>在Xcode 9中没有这样的烦恼了。</p>
<p>升级到Xcode9.0之后，可以通过Wifi连接iOS或tvOS设备进行无线调试。</p>
<p>要求: Xcode 9.0 以上版本、macOS 10.12.4以上版本、iOS 11.0以上版本, tvOS 11.0以上版本</p>
<p>操作步骤：</p>
<p>打开菜单 Window &gt; Devices and Simulators, 然后在打开的菜单中选择 Devices选项.</p>
<p>通过数据线将您的设备，比如iPhone，连接至Mac电脑.<br>在如下图选择连接的设备，然后在右侧勾选[通过网络连接]复选框.<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE8.png" alt=""><br>Xcode 会和你的设备进行配对. 一旦Xcode和设备配对成功，设备名称的右侧会显示一个网络图标<br><img src="http://ow7iaz7ej.bkt.clouddn.com/6%E5%9B%BE9.png" alt=""><br>最后将设备的数据线从Mac电脑上取出，就可以通过Wifi无线调试了！</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-最近学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/12/最近学习总结/" class="article-date">
  	<time datetime="2017-09-12T09:19:23.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/最近学习总结/">
        最近学习 JavaScript、node.js 的总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大前端全栈的热潮下，最近趁工作不太忙，学习了JavaScript，node.js，做一个小小的Demo来记录一下学习的过程。大佬勿喷。小Demo主要功能是记录用户的个人信息，可以对用户的个人信息进行增删改查。前端页面使用HTML +CSS实现，JavaScript控制逻辑，后台使用node.js实现。下面我分三部分总结一下。</p>
<h3 id="一、前端页面"><a href="#一、前端页面" class="headerlink" title="一、前端页面"></a>一、前端页面</h3><h4 id="1-1-页面"><a href="#1-1-页面" class="headerlink" title="1.1 页面"></a>1.1 页面</h4><p>网上传着一句话：不会点HTML+CSS都不敢说自己是程序员，所以写了几个简单的页面，也没有什么技术含量,都是div、span、ul、li、input之类的标签。</p>
<p>下图就是我写的页面！</p>
<p><img src="http://ow7iaz7ej.bkt.clouddn.com/5nocss1.png" alt="首页无CSS"><br><img src="http://ow7iaz7ej.bkt.clouddn.com/5nocss2.png" alt="增加页无CSS"></p>
<h4 id="1-2-CSS"><a href="#1-2-CSS" class="headerlink" title="1.2 CSS"></a>1.2 CSS</h4><p>哈哈是不是太丑了，那肯定不是有三个星期CSS功力的我写的页面，简单的加入点CSS样式之后，这才是我写的。</p>
<p><img src="http://ow7iaz7ej.bkt.clouddn.com/5css1.png" alt="首页CSS"><br><img src="http://ow7iaz7ej.bkt.clouddn.com/5css2.png" alt="增加页CSS"><br>css也就是 margin、padding、width、height等值的配置，当然变成一个高手这些远远不够。</p>
<h3 id="二、前端服务器交互（AJAX）"><a href="#二、前端服务器交互（AJAX）" class="headerlink" title="二、前端服务器交互（AJAX）"></a>二、前端服务器交互（AJAX）</h3><p>只是做前端的相比都知道AJAX，这里说说我只怎么处理各个浏览器兼容，并且很高效<br><strong>问题引出：</strong> 犹豫IE低版本不兼容XMLHttpRequest，所以每次调用AJAX就需要判断是否兼容，然后在调用合适的方法，假如浏览器用AJAX调用100个请求，那就要判断100次兼容。所以非常消耗性能和时间。<br><strong>解决思想：</strong> 第一次执行creatXHR函数的时候，需要兼容判断，在判断完成后，直接把创建AJAX函数赋值(这里举例AJAX函数赋值就是A)给creatXHR函数，那么以后调用creatXHR函数的时候执行的就是AJAX函数赋值（A)，可以省去其中的兼容性判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">function creatXHR() &#123;</div><div class="line">        var xhr = null,</div><div class="line">            flag = false,</div><div class="line">            ary = [</div><div class="line">                function () &#123;</div><div class="line">                    return new XMLHttpRequest;</div><div class="line">                &#125;,</div><div class="line">                function () &#123;</div><div class="line">                    return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">                &#125;,</div><div class="line">                function () &#123;</div><div class="line">                    return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</div><div class="line">                &#125;,</div><div class="line">                function () &#123;</div><div class="line">                    return new ActiveXObject(&quot;Msxml3.XMLHTTP&quot;);</div><div class="line">                &#125;</div><div class="line">            ];</div><div class="line"></div><div class="line">        for (var i = 0, len = ary.length; i &lt; len; i++) &#123;</div><div class="line">            var curFn = ary[i];</div><div class="line">            try &#123;</div><div class="line">                xhr = curFn();</div><div class="line">                creatXHR = curFn;</div><div class="line">                flag = true;</div><div class="line">                break;</div><div class="line">            &#125; catch (e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (!flag) &#123;</div><div class="line">            throw new Error(&quot;your browser is not support ajax,please change you broser,try again&quot;);</div><div class="line">        &#125;</div><div class="line">        return xhr;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>AJAX向服务器端发送请求的四个步骤；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var xhr = creatXHR();//1、创建对象</div><div class="line">    xhr.open(_default.type, _default.url, _default.async);//2、请求类型，网址，是否异步</div><div class="line">    xhr.onreadystatechange = function () &#123;</div><div class="line">                &#125;;//3、状态变化监听函数</div><div class="line">    xhr.send(_default.data);//4、发送请求</div></pre></td></tr></table></figure></p>
<p>Demo中处理网络请求核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">function ajax(option) &#123;</div><div class="line">        var _default = &#123;</div><div class="line">            url: &quot;&quot;,</div><div class="line">            type: &quot;get&quot;,</div><div class="line">            dataType: &quot;json&quot;,</div><div class="line">            async: true,</div><div class="line">            data: null,</div><div class="line">            getHead: null,</div><div class="line">            success: null</div><div class="line">        &#125;;</div><div class="line">        for (var key in option) &#123;</div><div class="line">            if (option.hasOwnProperty(key)) &#123;</div><div class="line">                _default[key] = option[key];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //解决缓存问题</div><div class="line">        if (_default.type === &quot;get&quot;) &#123;</div><div class="line">            _default.url.indexOf(&quot;?&quot;) &gt;= 0 ? _default.url += &quot;&amp;&quot; : _default.url += &quot;?&quot;;</div><div class="line">            _default.url += &quot;_=&quot; + Math.random();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var xhr = creatXHR();</div><div class="line">        xhr.open(_default.type, _default.url, _default.async);</div><div class="line">        xhr.onreadystatechange = function () &#123;</div><div class="line">            if (/^2\d&#123;2&#125;$/.test(xhr.status)) &#123;</div><div class="line">                if (xhr.readyState === 2) &#123;</div><div class="line">                    if (typeof _default.getHead === &quot;function&quot;) &#123;</div><div class="line">                        _default.getHead.call(xhr);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (xhr.readyState === 4) &#123;</div><div class="line">                    var val = xhr.responseText;</div><div class="line">                    if (_default.dataType === &quot;json&quot;) &#123;</div><div class="line">                        val = &quot;JSON&quot; in window ? JSON.parse(val) : eval(&quot;(&quot; + val + &quot;)&quot;);</div><div class="line">                    &#125;</div><div class="line">                    _default.success &amp;&amp; _default.success.call(xhr, val);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        xhr.send(_default.data);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="三、后端（node-js）"><a href="#三、后端（node-js）" class="headerlink" title="三、后端（node.js）"></a>三、后端（node.js）</h3><h4 id="3-1-环境配置"><a href="#3-1-环境配置" class="headerlink" title="3.1 环境配置"></a>3.1 环境配置</h4><p>因为我事先安装好了，所以前两步操作无图（尴尬）<br>第一步:打开终端,输入以下命令安装Homebrew<br>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>);<br>第二步:安装node,在终端输入以下命令<br>brew install node<br>第三步 查看node安装成功与否<br>node -v<br><img src="http://ow7iaz7ej.bkt.clouddn.com/5nodeVersion.png" alt="查看是否验证安装node"></p>
<h4 id="3-2-node-js的最基本操作"><a href="#3-2-node-js的最基本操作" class="headerlink" title="3.2 node.js的最基本操作"></a>3.2 node.js的最基本操作</h4><p>1.node中提供的三个常用的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var http = require(&quot;http&quot;),</div><div class="line">    fs = require(&quot;fs&quot;),</div><div class="line">    url = require(&quot;url&quot;);</div></pre></td></tr></table></figure></p>
<p>2.静态资源文件请求的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function (req, res) &#123;</div><div class="line">	// 静态资源文件请求的处理</div><div class="line">	// 数据接口的处理</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3.服务创建成功执行回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">server.listen(8080, function () &#123;</div><div class="line">    //-&gt;当服务创建成功，并且端口号也监听成功之后执行这个回调函数</div><div class="line">    console.log(&quot;server is create success,listening on 8080 port!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="3-3-静态资源文件请求的处理"><a href="#3-3-静态资源文件请求的处理" class="headerlink" title="3.3 静态资源文件请求的处理"></a>3.3 静态资源文件请求的处理</h4><p>静态资源文件请求的处理其中重要的点是为了兼容，要对请求文件的MIME Type进行匹配。MIME Type是什么？<br>在浏览器中显示的内容HTML、XML、CSS、PNG、GIF…… 那么，浏览器是如何区分它们，决定什么内容用什么形式来显示？，答案是 MIME Type，也就是该资源的媒体类型。</p>
<p>参考链接：<a href="http://tool.oschina.net/commons" target="_blank" rel="external">http://tool.oschina.net/commons</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function (req, res) &#123;</div><div class="line">    var urlObj = url.parse(req.url, true),</div><div class="line">        pathname = urlObj.pathname,</div><div class="line">        query = urlObj.query;</div><div class="line">    var reg = /\.(HTML|CSS|JS|ICO)/i;</div><div class="line">    if (reg.test(pathname)) &#123;</div><div class="line">        var suffix = reg.exec(pathname)[1].toUpperCase();</div><div class="line">        var suffixMIME = &quot;text/html&quot;;</div><div class="line">        switch (suffix) &#123;</div><div class="line">            case &quot;CSS&quot;:</div><div class="line">                suffixMIME = &quot;text/css&quot;;</div><div class="line">                break;</div><div class="line">            case &quot;JS&quot;:</div><div class="line">                suffixMIME = &quot;text/javascript&quot;;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            var conFile = fs.readFileSync(&quot;.&quot; + pathname, &quot;utf-8&quot;);</div><div class="line">            res.writeHead(200, &#123;&apos;content-type&apos;: suffixMIME + &apos;;charset=utf-8;&apos;&#125;);</div><div class="line">            res.end(conFile);</div><div class="line">        &#125; catch (e) &#123;</div><div class="line">            res.writeHead(404, &#123;&apos;content-type&apos;: &apos;text/plain;charset=utf-8;&apos;&#125;);</div><div class="line">            res.end(&quot;file is not found~&quot;);</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<h4 id="3-4-API数据接口的处理"><a href="#3-4-API数据接口的处理" class="headerlink" title="3.4 API数据接口的处理"></a>3.4 API数据接口的处理</h4><p>这个是Demo实现了数据的增、删、改、查，所以这里简单的对增，删谈谈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 获取服务器端存储的数据</div><div class="line">var customId = null,</div><div class="line">    customPath = &quot;./json/custom.json&quot;,</div><div class="line">    result = &#123;code: 1, msg: &quot;&quot;, data: null&#125;,</div><div class="line">    con = fs.readFileSync(customPath, &quot;utf-8&quot;);</div><div class="line">con.length === 0 ? con = &apos;[]&apos; : null;</div><div class="line">con = JSON.parse(con);</div></pre></td></tr></table></figure>
<p>增加一条客户信息的时候要介绍一下node中requestListener的两个监听方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 在接收到数据的时候调用</div><div class="line">req.on(&quot;data&quot;, function (chunk) &#123;</div><div class="line">&lt;!--数据传到服务器不是一次接受到，而是一段一段的数据所以要对数据进行整合 其中参数chunk就是一段一段的数据--&gt;</div><div class="line">&#125;);</div><div class="line">// 在接收数据完成后调用</div><div class="line">req.on(&quot;end&quot;, function () &#123;</div><div class="line">&lt;!--数据传递完之后调用，调用之前要先判断数据是否为空--&gt;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>增加一条客户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> // 增加一条客户信息相关代码</div><div class="line">if (pathname === &quot;/addInfo&quot;) &#123;</div><div class="line">        //-&gt;获取客户端通过请求主体传递进来的内容</div><div class="line">        var str = &apos;&apos;;</div><div class="line">        req.on(&quot;data&quot;, function (chunk) &#123;</div><div class="line">            str += chunk;</div><div class="line">        &#125;);</div><div class="line">        req.on(&quot;end&quot;, function () &#123;</div><div class="line">            if (str.length === 0) &#123;</div><div class="line">                res.writeHead(200, &#123;&apos;content-type&apos;: &apos;application/json;charset=utf-8;&apos;&#125;);</div><div class="line">                res.end(JSON.stringify(&#123;</div><div class="line">                    code: 1,</div><div class="line">                    msg: &quot;增加失败,没有传递任何需要增加的信息&quot;</div><div class="line">                &#125;));</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            var data = JSON.parse(str);</div><div class="line">            //-&gt;在现有的DATA中追加一个ID:获取CON中最后一项的ID,新的ID是在原有基础上加一即可,如果之前一项都没有,我们这一项的ID就是1</div><div class="line">            data[&quot;id&quot;] = con.length === 0 ? 1 : parseFloat(con[con.length - 1][&quot;id&quot;]) + 1;</div><div class="line">            con.push(data);</div><div class="line">            fs.writeFileSync(customPath, JSON.stringify(con), &quot;utf-8&quot;);</div><div class="line">            res.end(JSON.stringify(&#123;</div><div class="line">                code: 0,</div><div class="line">                msg: &quot;增加成功!&quot;</div><div class="line">            &#125;));</div><div class="line">        &#125;);</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>根据传入的用户ID删除这个用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//3)根据传递进来的客户ID删除这个客户</div><div class="line">    if (pathname === &quot;/removeInfo&quot;) &#123;</div><div class="line">        customId = query[&quot;id&quot;];</div><div class="line">        var flag = false;</div><div class="line">        for (i = 0; i &lt; con.length; i++) &#123;</div><div class="line">            if (con[i][&quot;id&quot;] == customId) &#123;</div><div class="line">                con.splice(i, 1);</div><div class="line">                flag = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        result.msg = &quot;删除失败&quot;;</div><div class="line">        if (flag) &#123;</div><div class="line">            fs.writeFileSync(customPath, JSON.stringify(con), &quot;utf-8&quot;);</div><div class="line">            result = &#123;</div><div class="line">                code: 0,</div><div class="line">                msg: &quot;删除成功&quot;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        res.writeHead(200, &#123;&apos;content-type&apos;: &apos;application/json;charset=utf-8;&apos;&#125;);</div><div class="line">        res.end(JSON.stringify(result));</div><div class="line">        return;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="四、Demo演示"><a href="#四、Demo演示" class="headerlink" title="四、Demo演示"></a>四、Demo演示</h3><p>演示由于服务器中配置的端口号是8080，所以网址的时候需要加上端口号，<br>现在打开页面（不是本地的页面），通过IP访问。已经不是静态页面了。</p>
<p><img src="http://ow7iaz7ej.bkt.clouddn.com/5ip.png" alt="Demo演示"></p>
<p>因为自己平时学习，所以服务器弄在自己电脑上，所以这里的IP就是我电脑的IP地址。<br>在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>增加操作：<br><img src="http://ow7iaz7ej.bkt.clouddn.com/5add.gif" alt="Demo演示"></p>
<p>删除操作：<br><img src="http://ow7iaz7ej.bkt.clouddn.com/5delete.gif" alt="Demo演示"></p>
<p>项目地址 <strong>麻烦各位大佬给个Star</strong>：<a href="https://github.com/leerme/NodeDemo" target="_blank" rel="external">https://github.com/leerme/NodeDemo</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-算法最长无重复子串" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/09/07/算法最长无重复子串/" class="article-date">
  	<time datetime="2017-09-07T03:26:35.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/算法最长无重复子串/">
        Longest Substring Without Repeating Characters
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>最近在LeetCode上刷题，把自己平时学习的过程记录下来。
</code></pre><h1 id="没有重复字符的最长子串"><a href="#没有重复字符的最长子串" class="headerlink" title="没有重复字符的最长子串"></a>没有重复字符的最长子串</h1><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:<br>Given “abcabcbb”, the answer is “abc”, which the length is 3.<br>Given “bbbbb”, the answer is “b”, with the length of 1.<br>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<p>下面是本人的swift实现方法，思路过于麻烦时间复杂度O(n^3);导致在字符串很长的时候超时，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123;</div><div class="line">        var resoult = 0 ;</div><div class="line">        var string = &quot;&quot;;</div><div class="line"></div><div class="line">        for i in 0 ..&lt; s.characters.count&#123;</div><div class="line">            for j in i+1 ... s.characters.count &#123;</div><div class="line">                let indexI = s.index(s.startIndex, offsetBy: i);</div><div class="line">                let indexJ = s.index(s.startIndex, offsetBy: j);</div><div class="line">                string = s.substring(with: indexI..&lt;indexJ);</div><div class="line">                if self.allUnique(string) &#123;</div><div class="line">                    resoult = max(resoult, string.characters.count);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return resoult;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    func allUnique(_ string:String) -&gt; Bool &#123;</div><div class="line">        var set:Set&lt;Character&gt; = [];</div><div class="line">        for i in 0 ..&lt; string.characters.count &#123;</div><div class="line">            </div><div class="line">            let index = string.index(string.startIndex,offsetBy:i)</div><div class="line">            let c = string[index];</div><div class="line">            </div><div class="line">            if set.contains(c) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            set.insert(c);</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优化：方法2-Sliding-Window"><a href="#优化：方法2-Sliding-Window" class="headerlink" title="优化：方法2 Sliding Window"></a>优化：方法2 Sliding Window</h3><p>The naive approach is very straightforward. But it is too slow. So how can we optimize it?</p>
<p>In the naive approaches, we repeatedly check a substring to see if it has duplicate character. But it is unnecessary. If a substring s<sub>ij</sub> from index i to j - 1 is already checked to have no duplicate characters. We only need to check if s[j] is already in the substring s<sub>ij</sub>s<br>​ij.<br>To check if a character is already in the substring, we can scan the substring, which leads to an O(n^2) algorithm. But we can do better.<br>By using HashSet as a sliding window, checking if a character in the current can be done in O(1).<br>A sliding window is an abstract concept commonly used in array/string problems. A window is a range of elements in the array/string which usually defined by the start and end indices, i.e. [i, j) (left-closed, right-open). A sliding window is a window “slides” its two boundaries to the certain direction. For example, if we slide [i, j)to the right by 11 element, then it becomes [i+1, j+1)(left-closed, right-open).<br>Back to our problem. We use HashSet to store the characters in current window [i, j)(j = i initially). Then we slide the index jj to the right. If it is not in the HashSet, we slide jj further. Doing so until s[j] is already in the HashSet. At this point, we found the maximum size of substrings without duplicate characters start with index ii. If we do this for all ii, we get our answer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        int n = s.length();</div><div class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</div><div class="line">        int ans = 0, i = 0, j = 0;</div><div class="line">        while (i &lt; n &amp;&amp; j &lt; n) &#123;</div><div class="line">            // try to extend the range [i, j]</div><div class="line">            if (!set.contains(s.charAt(j)))&#123;</div><div class="line">                set.add(s.charAt(j++));</div><div class="line">                ans = Math.max(ans, j - i);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                set.remove(s.charAt(i++));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Complexity Analysis</p>
<p>Time complexity : O(2n) = O(n). In the worst case each character will be visited twice by i and j.</p>
<p>Space complexity : O(min(m, n)) Same as the previous approach. We need O(k) space for the sliding window, where k is the size of the Set. The size of the Set is upper bounded by the size of the string n and the size of the charset/alphabet m;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-iOS事件的传递和响应" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/24/iOS事件的传递和响应/" class="article-date">
  	<time datetime="2017-08-24T02:41:45.000Z" itemprop="datePublished">2017-08-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/iOS事件的传递和响应/">
        iOS 事件的传递和响应
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>谈一谈iOS事件的产生和传递
</code></pre><h1 id="1-事件的产生"><a href="#1-事件的产生" class="headerlink" title="1.事件的产生"></a>1.事件的产生</h1><ul>
<li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中.</li>
<li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。</li>
<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步</li>
</ul>
<h1 id="2-事件的传递"><a href="#2-事件的传递" class="headerlink" title="2.事件的传递"></a>2.事件的传递</h1><ol>
<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件</li>
<li>判断触摸点是否在自己身上</li>
<li>子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤</li>
<li>view，比如叫做subView，那么会把这个事件交给这个subView，再遍历这个subView的子控件，直至没有更合适的view为止</li>
<li>如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view</li>
</ol>
<h3 id="UIView不能接收触摸事件的三种情况："><a href="#UIView不能接收触摸事件的三种情况：" class="headerlink" title="UIView不能接收触摸事件的三种情况："></a>UIView不能接收触摸事件的三种情况：</h3><ul>
<li><strong>不允许交互</strong>：userInteractionEnabled = NO</li>
<li><strong>隐藏</strong>：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件</li>
<li><strong>透明度</strong>：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。</li>
</ul>
<p><strong>注 意</strong>:默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO，所以如果希望UIImageView可以交互，需要userInteractionEnabled = YES。发生在事件传递的时候。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>点击一个UIView或产生一个触摸事件A，这个触摸事件A会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。</li>
<li>UIApplication会从事件对列中取出最前面的事件（此处假设为触摸事件A），把事件A传递给应用程序的主窗口（keyWindow）。</li>
<li>窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成）</li>
</ol>
<p><img src="http://ow7iaz7ej.bkt.clouddn.com/3iosevent.png" alt="iOS事件示例"></p>
<p>如果想让某个view不能接收事件（或者说，事件传递到某个view那里就断了），那么可以通过刚才提到的三种方式。比如，设置其userInteractionEnabled = NO;那么传递下来的事件就会由该view的父控件处理。<br>例如，不想让蓝色的view接收事件，那么可以设置蓝色的view的userInteractionEnabled = NO;那么点击黄色的view或者蓝色的view所产生的事件，橙色的view就会成为最合适的view。事件都会由橙色的veiw处理。<br>所以，不管视图能不能处理事件，只要点击了视图就都会产生事件，关键看该事件是由谁来处理！也就是说，如果蓝色视图不能处理事件，点击蓝色视图产生的触摸事件不会由被点击的视图（蓝色视图）处理！</p>
<p><strong>注意</strong>：如果设置父控件的透明度或者hidden，会直接影响到子控件的透明度和hidden。如果父控件的透明度为0或者hidden = YES，那么子控件也是不可见的！</p>
<h1 id="3-如何寻找最合适的view"><a href="#3-如何寻找最合适的view" class="headerlink" title="3.如何寻找最合适的view"></a>3.如何寻找最合适的view</h1><pre><code>应用如何找到最合适的控件来处理事件？
</code></pre><ol>
<li>首先判断主窗口（keyWindow）自己是否能接受触摸事件</li>
<li>触摸点是否在自己身上</li>
<li>从后往前遍历子控件，重复前面的两个步骤（首先查找数组中最后一个元素）</li>
<li>如果没有符合条件的子控件，那么就认为自己最合适处理</li>
</ol>
<p><strong>详述：</strong><br>1、主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上<br>2、如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view）<br>3、遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上）<br>4、如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。<br>找到最合适的view后，就会调用该view的touches方法处理具体的事件。所以，只有找到最合适的view，把事件传递给最合适的view后，才会调用touches方法进行接下来的事件处理。找不到最合适的view，就不会调用touches方法进行事件处理。<br>注意：之所以会采取从后往前遍历子控件的方式寻找最合适的view只是为了做一些循环优化。因为相比较之下，后添加的view在上面，降低循环次数。</p>
<h2 id="3-1-寻找最合适的view底层剖析"><a href="#3-1-寻找最合适的view底层剖析" class="headerlink" title="3.1.寻找最合适的view底层剖析"></a>3.1.寻找最合适的view底层剖析</h2><p>两个重要的方法：<br>hitTest:withEvent:方法<br>pointInside方法</p>
<h3 id="3-1-1-hitTest：withEvent：方法"><a href="#3-1-1-hitTest：withEvent：方法" class="headerlink" title="3.1.1.hitTest：withEvent：方法"></a>3.1.1.hitTest：withEvent：方法</h3><h4 id="什么时候调用？"><a href="#什么时候调用？" class="headerlink" title="什么时候调用？"></a>什么时候调用？</h4><pre><code>只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法
</code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><pre><code>寻找并返回最合适的view(能够响应事件的那个最合适的view)
</code></pre><p><strong>注 意：</strong>不管这个控件能不能处理事件，也不管触摸点在不在这个控件上，事件都会先传递给这个控件，随后再调用hitTest:withEvent:方法</p>
<h4 id="拦截事件的处理"><a href="#拦截事件的处理" class="headerlink" title="拦截事件的处理"></a>拦截事件的处理</h4><ul>
<li>正因为hitTest：withEvent：方法可以返回最合适的view，所以可以通过重写hitTest：withEvent：方法，返回指定的view作为最合适的view。</li>
<li>不管点击哪里，最合适的view都是hitTest：withEvent：方法中返回的那个view。</li>
<li>通过重写hitTest：withEvent：，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。<br>事件传递给谁，就会调用谁的hitTest:withEvent:方法。</li>
</ul>
<p><strong>注 意：如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。<br>所以事件的传递顺序是这样的：<br>　　产生触摸事件-&gt;UIApplication事件队列-&gt;[UIWindow hitTest:withEvent:]-&gt;返回更合适的view-&gt;[子控件 hitTest:withEvent:]-&gt;返回最合适的view</strong><br>　　<br>事件传递给窗口或控件的后，就调用hitTest:withEvent:方法寻找更合适的view。所以是，先传递事件，再根据事件在自己身上找更合适的view。<br>不管子控件是不是最合适的view，系统默认都要先把事件传递给子控件，经过子控件调用自己的hitTest:withEvent:方法验证后才知道有没有更合适的view。即便父控件是最合适的view了，子控件的hitTest:withEvent:方法还是会调用，不然怎么知道有没有更合适的！即，如果确定最终父控件是最合适的view，那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的。<br>技巧：想让谁成为最合适的view就重写谁自己的父控件的hitTest:withEvent:方法返回指定的子控件，或者重写自己的hitTest:withEvent:方法 return self。但是，建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！</p>
<p>原因在于在自己的hitTest:withEvent:方法中返回自己有时候会出现问题。因为会存在这么一种情况：当遍历子控件时，如果触摸点不在子控件A自己身上而是在子控件B身上，还要要求返回子控件A作为最合适的view，采用返回自己的方法可能会导致还没有来得及遍历A自己，就有可能已经遍历了点真正所在的view，也就是B。这就导致了返回的不是自己而是触摸点真正所在的view。所以还是建议在父控件的hitTest:withEvent:中返回子控件作为最合适的view！<br>例如：whiteView有redView和greenView两个子控件。redView先添加，greenView后添加。如果要求无论点击那里都要让redView作为最合适的view（把事件交给redView来处理）那么只能在whiteView的hitTest:withEvent:方法中return self.subViews[0];这种情况下在redView的hitTest:withEvent:方法中return self;是不好使的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 这里redView是whiteView的第0个子控件</div><div class="line">#import &quot;redView.h&quot;</div><div class="line"></div><div class="line">@implementation redView</div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; </div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; </div><div class="line">    NSLog(@&quot;red-touch&quot;);</div><div class="line">&#125;@end</div><div class="line">// 或者</div><div class="line">#import &quot;whiteView.h&quot;</div><div class="line"></div><div class="line">@implementation whiteView</div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; </div><div class="line">    return self.subviews[0];</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; </div><div class="line">    NSLog(@&quot;white-touch&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>hit:withEvent:方法底层会调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。</p>
<h3 id="3-1-2-pointInside-withEvent-方法"><a href="#3-1-2-pointInside-withEvent-方法" class="headerlink" title="3.1.2.pointInside:withEvent:方法"></a>3.1.2.pointInside:withEvent:方法</h3><p>pointInside:withEvent:方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。</p>
<h1 id="4事件的响应"><a href="#4事件的响应" class="headerlink" title="4事件的响应"></a>4事件的响应</h1><h2 id="4-1-触摸事件处理的整体过程"><a href="#4-1-触摸事件处理的整体过程" class="headerlink" title="4.1.触摸事件处理的整体过程"></a>4.1.触摸事件处理的整体过程</h2><p>1&gt;用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件2&gt;找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理touchesBegan…touchesMoved…touchedEnded…3&gt;这些touches方法的默认做法是将事件顺着响应者链条向上传递（也就是touch方法默认不处理事件，只传递事件），将事件交给上一个响应者进行处理</p>
<h2 id="4-2-响应者链条示意图"><a href="#4-2-响应者链条示意图" class="headerlink" title="4.2.响应者链条示意图"></a>4.2.响应者链条示意图</h2><p><strong>响应者链条</strong>：在iOS程序中无论是最后面的UIWindow还是最前面的某个按钮，它们的摆放是有前后关系的，一个控件可以放到另一个控件上面或下面，那么用户点击某个控件时是触发上面的控件还是下面的控件呢，这种先后关系构成一个链条就叫“响应者链”。也可以说，响应者链是由多个响应者对象连接起来的链条。</p>
<p><strong>响应者对象</strong>：能处理事件的对象，也就是继承自UIResponder的对象<br><strong>作用</strong>：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</p>
<h4 id="如何判断上一个响应者"><a href="#如何判断上一个响应者" class="headerlink" title="如何判断上一个响应者"></a>如何判断上一个响应者</h4><ol>
<li>如果当前这个view是控制器的view,那么控制器就是上一个响应者</li>
<li>如果当前这个view不是控制器的view,那么父控件就是上一个响应者<br>响应者链的事件传递过程:</li>
</ol>
<h4 id="事件处理的整个流程总结："><a href="#事件处理的整个流程总结：" class="headerlink" title="事件处理的整个流程总结："></a>事件处理的整个流程总结：</h4><ol>
<li>触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。</li>
<li>UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。</li>
<li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)</li>
<li>最合适的view会调用自己的touches方法处理事件</li>
<li>touches默认做法是把事件顺着响应者链条向上抛。</li>
</ol>
<h4 id="事件的传递与响应："><a href="#事件的传递与响应：" class="headerlink" title="事件的传递与响应："></a>事件的传递与响应：</h4><ol>
<li><p>当一个事件发生后，事件会从父控件传给子控件，也就是说由UIApplication -&gt; UIWindow -&gt; UIView -&gt; initial view,以上就是事件的传递，也就是寻找最合适的view的过程。</p>
</li>
<li><p>接下来是事件的响应。首先看initial view能否处理这个事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传 递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃</p>
</li>
<li><p>在事件的响应中，如果某个控件实现了touches…方法，则这个事件将由该控件来接受，如果调用了[supertouches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者；接着就会调用上一个响应者的touches….方法</p>
</li>
</ol>
<h4 id="如何做到一个事件多个对象处理："><a href="#如何做到一个事件多个对象处理：" class="headerlink" title="如何做到一个事件多个对象处理："></a>如何做到一个事件多个对象处理：</h4><p>因为系统默认做法是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。</p>
<figure class="highlight plain"><figcaption><span>(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 1.自己先处理事件...</div><div class="line">NSLog(@&quot;do somthing...&quot;);</div><div class="line">// 2.再调用系统的默认做法，再把事件交给上一个响应者处理</div><div class="line">[super touchesBegan:touches withEvent:event]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="事件的传递和响应的区别："><a href="#事件的传递和响应的区别：" class="headerlink" title="事件的传递和响应的区别："></a>事件的传递和响应的区别：</h4><p>事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。</p>
<p>参考链接：<a href="http://www.jianshu.com/p/2e074db792ba" target="_blank" rel="external">http://www.jianshu.com/p/2e074db792ba</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ReactNative" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/27/ReactNative/" class="article-date">
  	<time datetime="2017-06-27T05:52:15.000Z" itemprop="datePublished">2017-06-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/27/ReactNative/">
        iOS React/RCTBundleURLProvider.h&#39; file not found
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>学习React Native使用react-native init 项目名称之后运行项目，编译就报React/RCTBundleURLProvider.h&apos; file not found怎么办。
</code></pre><h3 id="下面先看一下实现效果"><a href="#下面先看一下实现效果" class="headerlink" title="下面先看一下实现效果."></a>下面先看一下实现效果.</h3><div align="center"><br><img src="http://ow7iaz7ej.bkt.clouddn.com/2reactnative.png" alt="屏幕截图"><br></div>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原来是新版本有问题<br>新建项目指定版本：<br>用–version参数创建指定版本的项目。例如react-native init ceshi –version 0.44.3注意版本号必须精确到两个小数点。<br>项目创建好之后：执行：react-native run-ios</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-右滑返回" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/23/右滑返回/" class="article-date">
  	<time datetime="2017-03-23T05:52:15.000Z" itemprop="datePublished">2017-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/23/右滑返回/">
        iOS | 右滑返回
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>苹果系统自带的右滑返回方便方便人们更好的使用APP，前几天老总就提了这个需求，今天结合自己项目谈一谈，产品设计的需求诡异，打破了系统默认的页面跳转规则（Push、Pop），各个页面神跳转(好了不吐槽了),需要自己自定义NavigationController从而导致系统自带的右滑返回失效。</p>
<h3 id="下面先看一下实现效果"><a href="#下面先看一下实现效果" class="headerlink" title="下面先看一下实现效果."></a>下面先看一下实现效果.</h3><div align="center"><br><img src="http://ow7iaz7ej.bkt.clouddn.com/1rightSlide.gif" alt="屏幕截图"><br></div>

<h3 id="效果还不错吧-直接上代码"><a href="#效果还不错吧-直接上代码" class="headerlink" title="效果还不错吧,直接上代码"></a>效果还不错吧,直接上代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"LYNavigationController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LYNavigationController</span> () &lt;<span class="title">UIGestureRecognizerDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LYNavigationController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"><span class="comment">//  这句很核心 稍后讲解</span></div><div class="line"><span class="keyword">id</span> target = <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate;</div><div class="line"><span class="comment">//  这句很核心 稍后讲解</span></div><div class="line">SEL handler = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);</div><div class="line"><span class="comment">//  获取添加系统边缘触发手势的View</span></div><div class="line"><span class="built_in">UIView</span> *targetView = <span class="keyword">self</span>.interactivePopGestureRecognizer.view;</div><div class="line"></div><div class="line"><span class="comment">//  创建pan手势 作用范围是全屏</span></div><div class="line"><span class="built_in">UIPanGestureRecognizer</span> * fullScreenGes = [[<span class="built_in">UIPanGestureRecognizer</span> alloc]initWithTarget:target action:handler];</div><div class="line">fullScreenGes.delegate = <span class="keyword">self</span>;</div><div class="line">[targetView addGestureRecognizer:fullScreenGes];</div><div class="line"></div><div class="line"><span class="comment">// 关闭边缘触发手势 防止和原有边缘手势冲突</span></div><div class="line">[<span class="keyword">self</span>.interactivePopGestureRecognizer setEnabled:<span class="literal">NO</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  防止导航控制器只有一个rootViewcontroller时触发手势</span></div><div class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer &#123;</div><div class="line"><span class="comment">//解决与左滑手势冲突</span></div><div class="line"><span class="built_in">CGPoint</span> translation = [gestureRecognizer translationInView:gestureRecognizer.view];</div><div class="line"><span class="keyword">if</span> (translation.x &lt;= <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">self</span>.childViewControllers.count == <span class="number">1</span> ? <span class="literal">NO</span> : <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div></pre></td></tr></table></figure>
<p>在实现之前,先推测一下苹果实现pop的大概思路.首先,需要在一个合适的view上添加边缘手势,其次,针对这个手势必然要实现一个方法响应该事件.当然,根据苹果一贯代码风格,处理该事件很可能交给另一个专门的类去处理.</p>
<p>假如以上推测成立,只要获得那个专门处理事件的类和方法,实现全屏pop效果就很简单了.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(lldb) pclass [<span class="keyword">self</span> interactivePopGestureRecognizer]</div><div class="line"><span class="comment">// 信息-&gt;1</span></div><div class="line"><span class="built_in">UIScreenEdgePanGestureRecognizer</span></div><div class="line">| <span class="built_in">UIPanGestureRecognizer</span></div><div class="line">|    | <span class="built_in">UIGestureRecognizer</span></div><div class="line">|    |    | <span class="built_in">NSObject</span></div><div class="line">(lldb) pclass [<span class="keyword">self</span> interactivePopGestureRecognizer].delegate</div><div class="line"><span class="comment">// 信息-&gt;2</span></div><div class="line">_UINavigationInteractiveTransition</div><div class="line">| _UINavigationInteractiveTransitionBase</div><div class="line">|    | <span class="built_in">UIPercentDrivenInteractiveTransition</span></div><div class="line">|    |    | <span class="built_in">NSObject</span></div><div class="line">(lldb) po [<span class="keyword">self</span> interactivePopGestureRecognizer]</div><div class="line"><span class="comment">// 信息-&gt;3</span></div><div class="line">&lt;<span class="built_in">UIScreenEdgePanGestureRecognizer</span>: <span class="number">0x7fab1243be00</span>; state = Possible; enabled = <span class="literal">NO</span>; delaysTouchesBegan = <span class="literal">YES</span>; view = &lt;<span class="built_in">UILayoutContainerView</span> <span class="number">0x7fab126a4a60</span>&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition <span class="number">0x7fab1243b850</span>&gt;)&gt;&gt;</div><div class="line"></div><div class="line">(lldb) po [<span class="keyword">self</span> interactivePopGestureRecognizer].delegate</div><div class="line"><span class="comment">// 信息-&gt;4</span></div><div class="line">&lt;_UINavigationInteractiveTransition: <span class="number">0x7fab1243b850</span>&gt;</div><div class="line"></div><div class="line">(lldb)</div></pre></td></tr></table></figure>
<p>从信息1中,可以知道interactivePopGestureRecognizer属性并不是UIGestureRecognizer类型的对象,而是其子类UIPanGestureRecognizer的子类UIScreenEdgePanGestureRecognizer类型的对象.</p>
<p>UIScreenEdgePanGestureRecognizer是边缘触发手势,在系统中公有API,里面只有一个edges属性,用来设置具体边缘有效,如左边缘.具体可以参考官方API.</p>
<p>在信息3中,可以看到<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target= (action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition x7fab1243b850&gt;)</div></pre></td></tr></table></figure><br>这样一条信息,里面包含了target和action.看到这是不是很兴奋?iOS开发者再也属性不过的目标-动作模式了.</p>
<p>到这里,已经可以确定苹果的实现方式是通过边缘触发手势处理pop的.这里target是私有的,如何获得呢?于是,网上很多人开始使用runtime来获得一些私有的方法.笔者一般不愿在正式上线的项目中使用runtime获得私有API,虽然不一定会被苹果拒接,但是会有一定风险</p>
<p>难道有没不用runtime的好方法?</p>
<p>先别着急,继续看信息2和4, interactivePopGestureRecognizer的代理是_UINavigationInteractiveTransition,看类名可以想到该类和交互转场相关.分析到这里,基本上可以推测出苹果是通过代理将事件处理委托给了_UINavigationInteractiveTransition对象.</p>
<p>在信息3中,可以看到target=<_uinavigationinteractivetransition 0x7fab1243b850="">的地址是0x7fab1243b850,信息4中<_uinavigationinteractivetransition: 0x7fab1243b850="">的地址也是0x7fab1243b850.</_uinavigationinteractivetransition:></_uinavigationinteractivetransition></p>
<p>由以上分析,可以确定苹果的实现方式是将处理边缘触发的事件的任务委托给了_UINavigationInteractiveTransition,在_UINavigationInteractiveTransition中有处理该事件的方法handleNavigationTransition:.</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> target = <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate;</div></pre></td></tr></table></figure>
<p>这句代码目的是获取事件处理对象.以便自己添加的手势可以把事件处理委托给它.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SEL handler = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"handleNavigationTransition:"</span>);</div></pre></td></tr></table></figure><br>这句就是获取委托对象里的处理方法.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIPanGestureRecognizer</span> * fullScreenGes = [[<span class="built_in">UIPanGestureRecognizer</span> alloc]initWithTarget:target action:handler];</div><div class="line">fullScreenGes.delegate = <span class="keyword">self</span>;</div><div class="line">[targetView addGestureRecognizer:fullScreenGes];</div></pre></td></tr></table></figure><br>这几句就是添加自己的全屏手势,通过目标-动作模式把任务交给了系统委托对象处理.</p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>如果需要自定制导航时,实现是写在UINavigationController子类中,比较方便.如果不需要,可以单独写一个分类.这里写在GLNavigationController中,其中GLNavigationController.h继承自UINavigationController.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 leerme
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>